## 2주차 딥바이브 주제: NumPy 배열의 생성과 연산이 데이터를 어떻게 처리하는지 설명하시오.

<aside>
💡

## → 딥다이브 한줄정리:

Numpy 배열은 **연속적인 메모리 저장**으로 효율적이고, 벡터화된 연산과 브로드캐스팅을 활용하여 대량의 데이터를 빠르게 처리한다.  

</aside>

---

## NumPy에서 배열의 생성이란?

Numpy에서 배열이란 다차원 데이터를 저장하는 자료구조.

### Numpy의 배열의 데이터 처리 방식

|  | **함수형태** | `데이터 처리` |
| --- | --- | --- |
| **기본 배열** 생성 | np.array | 값은 유지됨(기존 리스트나 튜플이 배열로 변환됨) |
| 특정 값으로 초기화 및 생성 | np.zeros
np.ones | 모든 원소가 0 혹은 1로 채워짐 |
| 연속된 숫자 배열 생성 | np.arrange
np.linspace | 일정한 간격으로 값이 증가됨  |
| 난수 배열 생성 | np.random.rand
np.random.randn
np.random.randint | 무작위 값이 저장됨(균등 분포, 정규 분포, 정수 난수) |

---

## Numpy에서 연산이란?

NumPy는 저장된 numpy 배열 성분끼리 다양한 수리 연산을 수행한다.

<aside>
💡

연산에서 NumPy를 사용하는 이유 (feat. Numpy의 빠른 데이터 처리)

1. C 언어 기반 코드
2. 메모리에 연속적으로 저장되어 CPU캐시를 최적화
3. 벡터화 연산: 반복문을 사용하지 않고 한 번에 배열 전체에 대해 연산을 수행하는 방식
4. 브로드캐스팅(broadcasting) 
</aside>

### **NumPy 연산의 데이터 처리 방식**

| NumPy 연산 | 함수형태 | `데이터 처리` |
| --- | --- | --- |
| 기본적인 사칙연산**(Arithmetic Operations) [(예제)](https://www.notion.so/2-a690a237664c4db6b2c2d35104c5720f?pvs=21)** | +, -, *, /, np.add(), np.subtract() | 데이터를 **확장**하는 연산, 크기 자체는 유지된다.

새로운 배열이 생성됨. 원본 배열은 변하지 않음. |
| 브로드캐스팅(broadcasting Operations) [(예제)](https://www.notion.so/2-a690a237664c4db6b2c2d35104c5720f?pvs=21) | [자동 배열 크기 조정](https://www.notion.so/2-a690a237664c4db6b2c2d35104c5720f?pvs=21) | 데이터를 **가상으로 확장**하는 연산, 연산 시에만 확장된다.

dim이 작은 배열에 자동 확장되어 큰 배열과 형태를 맞춘다.   |
| 선형대수 연산**(Linear Algebra Operations)** | np.dot(), @  **[(예제)](https://www.notion.so/2-a690a237664c4db6b2c2d35104c5720f?pvs=21)** | 단순한 크기 변환이 아닌, 데이터를 **합성**하는 연산. 

데이터를 **조합**하여 새로운 정보를 생성 |
|  | np.transpose(), .T [(예제)](https://www.notion.so/2-a690a237664c4db6b2c2d35104c5720f?pvs=21) | 데이터의 방향을 변경 하는 연산

값은 바뀌지 않지만, 행렬을 바꿈으로써 **데이터의 의미가 변함** |
| 통계 연산(Statistical Operations) [(예제)](https://www.notion.so/2-a690a237664c4db6b2c2d35104c5720f?pvs=21) | np.mean(), np.sum(), np.min(), np.max() | 데이터를 **요약**하는 연산 |
- 브로드캐스팅 예제
    
    ## 브로드캐스팅이 어떻게 확장되는가?
    
    <aside>
    💡
    
    브로드캐스팅은 실제 데이터 복사가 일어나지 않는다. **가상적**으로 변환되어 실제 메모리 복사가 없음.
    
    </aside>
    
    1. 1D vs 2D broadcasting 
        
        ```python
        a = np.array([1,2,3],[4,5,6]) # (2,3)
        b = np.array([10,11,12]) # (3,) -> (2,3)으로 *가상* 확장됨 
        # a+b 가능 / a @ b.T 가능
        ```
        
        ```
        A (2x3): 
        [[1 2 3]
         [4 5 6]]
        B (1x3) -> **(2x3) (가상 확장됨)**: 
        ([10,11,12],
        [10,11,12])
        ```
        
    2. 1D vs 3D broadcasting
        
        ```python
        a = np.array([1,2,3]) # (3,)
        b = np.array([[[10]],[[20]]]) #(2,1,1)
        ```
        
        ```
        (3,) -> (1,3) -> (1,1,3) 로 가상확장
        (2,1,1) -> (2,1,3)로 가상확장
        ```
        
    3. 두 배열이 다른 차원을 가지고 있을때, 자동 확장이 불가능할때 
        
        ```python
        arr1 = np.random.randint(10)
        arr2 = np.random.rand(10)
        arr1 = arr1.reshape(3,3) # (3,3)
        arr2 = arr2.reshape(2,5) # (2,5)
        
        arr1 = arr1.flatten() # (9,)
        arr2 = arr2.flatten() # (10,)
        
        arr2 = arr2[:,np.newaxis] # (10,1)
        ```
        

### **NumPy 연산 의미**

기본적인 사칙 연산

```python
arr = np.array([1,2,3,4])
res = arr * 10

# → arr 벡터의 10배 증가. arr자체의 크기는 그대로 유지됨.
```

브로드캐스팅(사이즈의 가상 확장)

```python
a = np.array([1,2,3], [4,5,6]) # -> (2,3) 
b = np.array([10,20,30]) # -> (3,) 가상의 축 생성!

#  -> 연산을 수행할 수 있도록 가상적으로 크기를 맞춤
```

선형대수 연산 (np.dot())

```python
a = np.array([[1,2], [3,4]])
b = np.array([[10,20],[30,40]])
c = a @ b # 기존 데이터를 합성하여 새로운 정보를 생성
```

선형대수 연산 (np.transpose())

```python
a = np.array([[1,2,3], [4,5,6]]) 
a.T # 기존 데이터를 유지하면서 방향의 전환
```

통계 연산 

```python
a = np.array([[1,2,3],[4,5,6]])
mean_a = np.mean(a)
mean_a0 = np.mean(a, axis=0)
mean_a1 = np.mean(a, axis=1)
```